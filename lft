#!/scratch/gpfs/jdh4/terminal-env/bin/python -u

# post issues to https://github.com/jdh4/lft
# or write to halverson@princeton.edu

# standard library
import os
from os.path import isdir
import sys
import subprocess
from subprocess import PIPE as sPIPE
from datetime import datetime
from time import time
from socket import gethostname

# conda environment
from blessed import Terminal

# self-written code
from panes import utils
from panes.utils import divider
from panes import dossier

class StringBox(list):
  def __init__(self):
    super().__init__()
    self.width = 0
    self.height = 0
  def append(self, x):
    super().append(x)
    self.width = len(x) if len(x) > self.width else self.width
    self.height += 1
  def __setitem__(self, key, x):
    super().__setitem__(key, x)
    self.width = len(x) if len(x) > self.width else self.width

######################################
## evaluate command-line parameters ##
######################################
def print_help():
  print("")
  print("lft is looking for trouble. Example usage:")
  print("     $ lft aturing")
  print("")
  print("Options:")
  print("     -v  Produce verbose output")
  print("     -d  Compute the size of /home using du -sh")
  print("     -h  Show this help menu")
  print("")
  sys.exit(0)

if (len(sys.argv) == 1 or len(sys.argv) > 4):
  print("")
  print("ERROR: Wrong number of command-line parameters.")
  print_help()
if ('-h' in sys.argv or '--help' in sys.argv):
  print_help()
verbose = True if ('-v' in sys.argv) else False
disk    = True if ('-d' in sys.argv) else False

###############################
## if __name__ == "__main__" ##
###############################

# check terminal size
term = Terminal()
width = 90
gutter = ' '
if (term.width < width):
  print(f"Terminal width too small ({term.width} < {width}). Exiting ...")
  sys.exit(0)

# translate hostname (e.g., della5.princeton.edu -> della)
hostname = gethostname().strip().lower()
if (hostname not in utils.known_hosts):
  print(f"{hostname} is unknown (see utils.py). Exiting ...")
  sys.exit(0)
host = utils.known_hosts[hostname]

# ldapsearch
username = sys.argv[1].strip()
person = dossier.ldap_plus([username])
netid = person[1][9]
if netid is None:
  print("")
  print(f"{username} not found in Princeton LDAP (or ldapsearch timed out). Exiting ...")
  print("")
  sys.exit(0)

# check for existence and permissions of /home on local cluster
home = f"/home/{netid}"
if isdir(home):
  home_exists = True
  if utils.is_rx(home):
    home_rx = True
  else:
    home_rx = False
else:
  home_exists = False
  home_rx = False

# clear terminal and print header
print(term.home + term.clear)
message = f"{gutter}looking for trouble"
now = datetime.today().strftime('%-I:%M %p (%b %-d)')
num_spaces = width - len(message) - len(now) - len(gutter)
print("=" * width)
print(f"{message}{' ' * num_spaces}{now}")
print("=" * width)

####################################
## print LDAP info about the user ##
####################################

# netid, name, dept, position
p = person[1]
if p[9]:
 if netid == username:
   print("   NetID:", term.bold(p[9]))
 else:
   print(f"   NetID: {term.bold(p[9])} ({term.red}{username} is alias{term.normal})")
if p[0]: print("    Name:", p[0])
print("  Groups:")
print("    Dept:", p[1]) if p[1] else print("    Dept: unknown")
print("Position:", p[3]) if p[3] else print("Position: unknown")

# modification time of /home
if isdir(home):
  mtime = datetime.fromtimestamp(os.stat(home).st_mtime)
  dt = datetime.today() - mtime
  if dt.days == 0:
    hours = dt.seconds // 3600
    minutes = dt.seconds // 60
    if hours > 1:
      print(f"  Active: {hours} hours ago")
    elif minutes > 1:
      print(f"  Active: {minutes} minutes ago")
    else:
      print(f"  Active: {dt.seconds} seconds ago")
  else:
    if dt.days < 365:
      print(f"  Active: {dt.days} days ago ({mtime.strftime('%b %-d')})")
    else:
      print(f"  Active: {dt.days} days ago ({mtime.strftime('%-m/%-d/%Y')})")
else:
  print("  Active: N/A")
print(" Sponsor:")

###############################
## .bashrc and .bash_profile ##
###############################
def format_modules(module_lines):
  # convert lines with multiple modules to single lines
  # e.g., module load intel intel-mpi cudatoolkit
  singles = []
  for module_line in module_lines:
    items = module_line.split()
    if len(items) > 1 and items[0] == 'module' and (items[1] == 'load' or items[1] == 'add'):
      for module in module_line.split()[2:]:
        #if module.endswith('/64'): module = module[:module.index('/64')]
        singles.append("module load " + module)
    else:
      singles.append(module_line)
  return singles

def remove_comments_and_white_space(lines):
  remove_comments = [line for line in lines if not line.strip().startswith('#')]
  trans = str.maketrans('', '', ' \n\t\r')
  return ''.join(remove_comments).translate(trans)

def analyze_startup_script(flnm, default, evars):
  aliases = 0
  exports = 0
  modules = []
  path = f"/home/{netid}/{flnm}"
  if os.path.isfile(path):
    with open(path) as f:
      lines = f.readlines()
    startup_rm = remove_comments_and_white_space(lines)
    default_rm = remove_comments_and_white_space(default)
    if (startup_rm == default_rm):
      state = "default"
    else:
      state = "custom"
      for line in lines:
        line = line.strip().lower()
        if line.startswith('#'): continue # ignore comments
        if (line.startswith('module') and ('load' in line or 'add' in line) and \
          not 'alias' in line):
          modules.append(line)
        if ('alias' in line): aliases += 1
        if ('export' in line): exports += 1
        if 'miniconda' in line and 'path' in line:
          evars['miniconda'] = True
        if 'anaconda' in line and 'path' in line:
          evars['anaconda'] = True
        if ('pythonpath' in line):
          evars['pythonpath'] = (True, flnm)
        if 'r_libs' in line and 'export' in line and '_user' not in line:
          evars['rlibs'] = (True, flnm)
        if 'r_libs_user' in line and 'export' in line:
          evars['rlibsuser'] = (True, flnm)
  else:
    state = "missing"
  return (aliases, exports, modules, state, flnm)

def print_with_modules(al, ex, modules, state, flnm):
  term = Terminal()
  print(f"{gutter}~/{flnm}: {state}")
  if modules:
    mods = format_modules(modules)
    if verbose or len(mods) < 4:
      for mod in mods:
        print(f"{gutter}  {term.bold}{term.red}{mod}{term.normal}")
    else:
      for mod in mods[:3]:
        print(f"{gutter}  {term.bold}{term.red}{mod}{term.normal}")
      print(f"{gutter}  {term.bold}{term.red}(plus {len(mods) - 3} more){term.normal}")

divider(f"{term.bold}Environment{term.normal}", '', gutter, width)

evars = {}
evars['miniconda'] = False
evars['anaconda'] = False
evars['pythonpath'] = (False, None)
evars['rlibs'] = (False, None)
evars['rlibsuser'] = (False, None)

if not home_exists:
  print(f"{gutter}{home} does not exist")
elif home_exists and not home_rx:
  print(f"{gutter}{home} is private")
else:
  rc = analyze_startup_script('.bashrc', utils.bashrc_default, evars)
  bp = analyze_startup_script('.bash_profile', utils.bash_profile_default, evars)
  if not rc[2] and not bp[2]:
    print(f"{gutter}      ~/.bashrc: {rc[3]}")
    print(f"{gutter}~/.bash_profile: {bp[3]}")
  else:
    print_with_modules(*rc)
    print_with_modules(*bp)

#################
## filesystems ##
#################
def public_or_private(path):
  if utils.is_rx(path):
    return f"{path}: public ({len(os.listdir(path))} items)"
  else:
    return f"{path}: private"

clusters = ['adroit', 'perseus', 'della', 'tiger', 'traverse']
is_cluster = any([cluster in host for cluster in clusters])

if is_cluster: # why do it this way? to distinguish from tigressdata?
  fs = StringBox()

  #path = '/home/' + netid
  #if isdir(path) and not is_rx(path):
  #  fs.append(f"{path}: private")

  path = '/scratch/gpfs/' + netid
  if isdir(path):
    fs.append(public_or_private(path))

  path = '/tigress/' + netid
  if isdir(path):
    fs.append(public_or_private(path))

  if ('della' in host or 'adroit' in host):
    path = '/scratch/network/' + netid
    if isdir(path):
      fs.append(public_or_private(path))

# align filesystems on colon
def align_on_colon(s):
  max_idx = max([line.index(':') for line in s])
  for i in range(fs.height):
    fs[i] = " " * (max_idx - fs[i].index(':')) + fs[i]
  return fs

if fs: fs = align_on_colon(fs)
if not home_exists or not home_rx: print("\n" * fs.height)
# print filesystems
with term.location():
  if len(fs):
    print(term.move_xy(width - fs.width - len(gutter), 12) + term.bold('Filesystems'))
    for i in range(fs.height):
      xc = width - fs.width - len(gutter)
      yc = 14 + i
      if 'home' in fs[i]:
        print(term.move_xy(xc, yc) + term.red + term.bold + fs[i] + term.normal)
      else:
        print(term.move_xy(xc, yc) + fs[i])

############
## groups ##
############
# TODO groups vary with cluster
cmd = "groups " + netid
output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
lines = output.stdout.decode("utf-8").split('\n')
# jdh4 : cses quijote (success)
# groups: aturing: no such user (fail)
grps = lines[0].split(':')[-1].split()
if len(grps) > 3:
  grps = ', '.join(grps[:3]) + ', ...'
else:
  grps = ', '.join(grps)
with term.location():
  print(term.move_xy(2, 6) + "Groups: " + grps)

######################
## home directories ##
######################
import csv
# TODO different path for adroit and tigressdata
# on adroit (and others?) consider: /home/jdh4/software/bin/lft
if host == "adroit":
  flnm = "/scratch/network/jdh4/python-utilities/.lft/combined_ls.csv"
elif host == "tigressdata":
  flnm = "/tiger/scratch/gpfs/jdh4/python-devel/lft/cron/combined_ls.csv"
else:
  flnm = "/tigress/jdh4/python-devel/lft/cron/combined_ls.csv"
with open(flnm, mode='r') as csv_file:
  csv_reader = csv.DictReader(csv_file)
  next(csv_reader)
  hdirs = []
  for row in csv_reader:
    if row["netid"] == netid:
      hdirs = [hdir for hdir in list(row.values())[1:] if hdir != '']
      break
if hdirs:
  with term.location(65, 4):
    print("/home")
    for hdir in sorted(hdirs):
      pre = "*" if hdir in host else " "
      print(term.move_x(67) + pre + hdir)

###########
## shell ##
###########
if home_exists:
  cmd = f"getent passwd {netid}"
  try:
    output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
  except:
    pass
  else:
    line = output.stdout.decode("utf-8")
    if line.count(":") > 0:
      shell = line.split(":")[-1].strip() if ":" in line else ""
      red = ["/bin/csh", "/bin/zsh", "/bin/tcsh", "/usr/bin/zsh", "/bin/sh", "bin/ksh"]
      if shell in red:
        print(f"{gutter}    login shell: {term.bold}{term.red}{shell}{term.normal}")
      if home_rx and os.path.isfile(f"/home/{netid}/.cshrc"):
        print(f"{gutter}{term.bold}{term.red}~/.cshrc exists{term.normal}")

####################
## sponsor_report ##
####################

# TODO luet does not have account on tiger
# TODO hwaight does not have a sponsor since only adroit account

# $ sponsor_report jdh4
# No sponsored users for jdh4 (Jonathan D. Halverson)
# This user is sponsored by curt

# $ sponsor_report aturing
# FATAL ERROR: Could not find user aturing in Princeton LDAP

# $ sponsor_report hwaight
# hwaight (Hannah C. Waight) has no Tigress account

# $ sponsor_report ethier
# Manager ethier (Stephane Ethier) has sponsored the following users
#      gascione (George Ascione) has accounts on eddy

# Cluster eddy has these users gascione

cmd = "sponsor_report " + netid
try:
  output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
except subprocess.TimeoutExpired:
  #print("sponsor_report timed out looking for", netid)
  sponsor = None
except:
  # netid not in Princeton LDAP
  sponsor = None
else:
  lines = output.stdout.decode("utf-8").split('\n')
  if len(lines) > 1 and 'No sponsored users' in lines[0]:
    sponsor = lines[1].split()[-1]
  elif "Manager" in lines[0] and "has sponsored" in lines[0]:
    sponsor = netid
  else:
    sponsor = None

if sponsor:
  accounts = []
  cmd = "sponsor_report " + sponsor
  try:
    output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
  except:
    pass
  else:
    lines = output.stdout.decode("utf-8").split('\n')
    for line in lines:
      if "Manager" in line and "has sponsored" in line:
        # Manager curt (Curtis W. Hillegas) has sponsored the following users
        sponsor_full_name = line.split('(')[1].split(')')[0]
        sponsor_full_name = utils.remove_middle_initial(sponsor_full_name)
        with term.location():
          print(term.move_xy(1, 10) + f"Sponsor: {sponsor_full_name} ({sponsor})")
      if 0 and netid in line and 'has accounts on' in line:
        # jdh4 (Jonathan D. Halverson) has accounts on della, perseus, tiger, traverse
        accounts = line.split('has accounts')[-1].replace(',', '').split()[1:]
        if 'mcmillan' in accounts: accounts.remove('mcmillan')
        if 'eddy' in accounts: accounts.remove('eddy')

if 0:
  # check for account adroit and tigressdata (use threading while sponsorreport runs)
  path = '/tigress/jdh4/python-devel/lft'
  with open(path + '/adroit_getent.txt', 'r') as f:
    adroit_users = f.readlines()
  for user in adroit_users:
    if user == netid + '\n':
     accounts.append("adroit")
  # check for account on tigressdata
  with open(path + '/tigressdata_getent.txt', 'r') as f:
    tg_users = f.readlines()
  for user in tg_users:
    if user == netid + '\n':
      accounts.append("tigressdata")
  # print accounts
  with term.location(50, 5):
    for account in sorted(accounts):
      pre = "*" if account in host else " "
      print(term.move_x(50) + pre + account)

############
## python ##
############
from panes import python as py

if home_exists and home_rx:
  py.python_packages(netid, evars, term, gutter, width, verbose)

#################
## R and julia ##
#################
from panes import r_and_julia as rj

if home_exists and home_rx:
  rj.r_packages(netid, evars, term, gutter, width, verbose)
  rj.julia_packages(netid, term, gutter, width, verbose)

############
## matlab ##
############
path = home + '/.matlab'
if home_exists and home_rx and isdir(path):
  if utils.is_rx(path):
    divider(term.bold('MATLAB'), '', gutter, width)
    # versions used via slurm or interactively
    versions_used = os.listdir(path)
    print(gutter + ' '.join(versions_used))

# ondemand
path = home + '/ondemand'
if home_exists and home_rx and isdir(path):
  if utils.is_rx(path):
    divider('ondemand', '', gutter, width)
    if isdir(path + '/data/sys/dashboard/batch_connect/sys/rstudio_server'):
      print("Ondemand RStudio")

###########################
## current and past jobs ##
###########################
from panes import jobs as jb

if home_exists:
  shares = jb.sshare(term, gutter, host, netid)
  jobs = jb.squeue(gutter, host, netid)
  if shares or jobs:
    divider(f"{term.bold}Jobs{term.normal}", "", gutter, width)
    for share in shares:
      print(share)
    if jobs: print(jobs)
  if lines: print('-' * width)
  lines = jb.sacct(gutter, host, netid)
  for line in lines:
    print(line)

# .ssh
# .Xauthority
# .allinea

###############
## reminders ##
###############
from panes import reminders as rms

downtime = rms.previous_and_next_downtime_dates(term, gutter)
reservations = rms.get_reservations(term, gutter, days_away=10)
reminders = rms.get_reminders(term, gutter, "holidays.csv", host, days_away=10)
reminders.extend(rms.get_reminders(term, gutter, "rc_workshops.csv", host, days_away=3))

if downtime or reservations or reminders:
  divider(f"{term.bold}Reminders{term.normal}", "", gutter, width)
  if downtime:
    print(downtime)
  if reservations:
    for r in reservations:
      print(r)
  if reminders:
    for r in reminders:
      print(r)

###################
## size of /home ##
###################
if home_exists and home_rx and disk:
  try:
    cmd = "du -sh /home/" + netid + " 2>/dev/null"
    output = subprocess.run(cmd, capture_output=True, shell=True, timeout=15)
    lines = output.stdout.decode("utf-8").split('\n')
    divider('size of /home on ' + host, '', gutter, width)
    print(lines[0].split('\t')[0])
  except subprocess.TimeoutExpired:
    divider(f"{term.bold}size of /home{term.normal}", "", gutter, width)
    print('du took too long')
  except:
    divider(f"{term.bold}size of /home{term.normal}", "", gutter, width)
    print("du failed so no info")

print("")
print("")
