#!/scratch/gpfs/jdh4/terminal-env/bin/python -u

# post issues to https://github.com/jdh4/lft
# or write to halverson@princeton.edu

import os
import sys
sys.path.append('/scratch/gpfs/jdh4/gpustat') # to find dossier
sys.path.append('/tiger/scratch/gpfs/jdh4/gpustat') # to find dossier on tigressdata
sys.path.append('/scratch/network/jdh4/gpustat') # to find dossier on adroit
import math
import subprocess
from subprocess import PIPE as sPIPE
from pathlib import Path
from datetime import datetime
from time import time
from socket import gethostname
from dossier import ldap_plus
from blessed import Terminal

class StringBox(list):
  def __init__(self):
    super().__init__()
    self.width = 0
    self.height = 0
  def append(self, x):
    super().append(x)
    self.width = len(x) if len(x) > self.width else self.width
    self.height += 1
  def __setitem__(self, key, x):
    super().__setitem__(key, x)
    self.width = len(x) if len(x) > self.width else self.width

def print_packages(pkgs, language, max_chars=15, columns=5):
  language = language.lower()
  if language == "python":
    parallel = ['mpi4py', 'mpich', 'intel_openmp', 'dask', 'joblib', 'tbb']
    gpu      = ['cudatoolkit', 'cudnn', 'cupy', 'numba', 'jax']
    green    = ['fenics', 'geopandas', 'tensorflow', 'tensorflow_gpu', \
                'torch', 'pystan', 'jupyter']
    red      = parallel + gpu
  elif language == "r":
    parallel = ['furrr', 'Rmpi', 'doMPI', 'caret']
    trouble  = ['sf', 'rstan', 'Rcpp']
    lock     = [pkg for pkg in pkgs if 'LOCK' in pkg]
    green    = []
    red      = parallel + trouble + lock
  elif language == "julia":
    green = ['Flux', 'GPUArrays', 'CUDAdrv', 'CUDAnative', 'CuArrays', \
             'TensorFlow', 'Knet', 'ScikitLearn']
    red = []
  else:
    green = []
    red = []
 
  clr = []
  for pkg in pkgs:
    if pkg in green:
      clr.append(f"{term.bold}{term.green}")
    elif pkg in red:
      clr.append(f"{term.bold}{term.red}")
    else:
      clr.append("")

  rows = math.ceil(len(pkgs) / columns)
  for i in range(rows):
    s = gutter
    for j in range(columns):
      idx = j + columns * i
      if idx >= len(pkgs): break
      pkg = pkgs[idx]
      if len(pkg) > max_chars - 1: pkg = pkg[:max_chars - 2] + '+ '
      s += clr[idx] + pkg + term.normal + ' ' * (max_chars - len(pkg))
    print(s)
  return None

def is_rx(path):
  # true if permissions are rx or rwx for other
  return oct(os.stat(path).st_mode)[-1] in ['5', '7']

def divider(title, msg):
  print("")
  print(" " + title)
  print("=" * width)
  if (msg != ''): print(msg)

######################################
## evaluate command-line parameters ##
######################################
def print_help():
  print("")
  print("lft is looking for trouble. Example usage:")
  print("     $ lft aturing")
  print("")
  print("Options:")
  print("     -h  Show this help menu")
  print("     -v  Produce verbose output")
  print("     -d  Compute the size of /home using du -sh")
  print("")
  sys.exit(0)

if (len(sys.argv) > 4):
  print("")
  print("ERROR: Wrong number of command-line parameters.")
  print_help()
if ('-h' in sys.argv or '--help' in sys.argv):
  print_help()
verbose = True if ('-v' in sys.argv) else False
disk    = True if ('-d' in sys.argv) else False

##############################
## terminal and preferences ##
##############################
term = Terminal()
width = 80
gutter = ' '
if (term.width < width):
  print(f"Terminal width too small ({term.width} < {width}). Exiting ...")
  sys.exit(0)

###############################
## if __name__ == "__main__" ##
###############################
username = sys.argv[1].strip()
person = ldap_plus([username])
netid = person[1][9]
if netid is None:
  print("")
  print(f"{username} not found in Princeton LDAP. Exiting ...")
  print("")
  sys.exit(0)

# check for existence and permissions of home directory
home = '/home/' + netid
if Path(home).is_dir():
  home_exists = True
  if is_rx(home):
    home_rx = True
  else:
    home_rx = False
    print(f"{home} is not accessible.")
else:
  home_exists = False
  home_rx = False
  print(f"{home} does not exist.")

host = gethostname().lower()
mach = {
'tigercpu.princeton.edu':'tiger',
'tigergpu.princeton.edu':'tiger',
'della5.princeton.edu':'della',
'perseus':'perseus',
'traverse.princeton.edu':'traverse',
'adroit4':'adroit',
'tigressdata2.princeton.edu':'tigressdata'}
if (host not in mach): print("WARNING: host not found.")
host = mach[host]


print(term.home + term.clear)
#message = f"{gutter}looking for trouble on {host} for {username}"
message = f"{gutter}looking for trouble"
now = datetime.today().strftime('%-I:%M %p (%b %-d)')
num_spaces = width - len(message) - len(now) - len(gutter)
print("=" * width)
print(f"{message}{' ' * num_spaces}{now}")
print("=" * width)

p = person[1]
if p[9]:
 if netid == username:
   print("   NetID:", term.bold(p[9]))
 else:
   print(f"   NetID: {term.bold(p[9])} ({term.red}{username} is alias{term.normal})")
if p[0]: print("    Name:", p[0])
print("  Groups:")
print("    Dept:", p[1]) if p[1] else print("    Dept: unknown")
print("Position:", p[3]) if p[3] else print("Position: unknown")

# modification time of /home/<NetID>
if Path(home).exists():
  mtime = datetime.fromtimestamp(os.stat(home).st_mtime)
  dt = datetime.today() - mtime
  if dt.days == 0:
    hours = dt.seconds // 3600
    minutes = dt.seconds // 60
    if hours > 1:
      print(f"  Active: {hours} hours ago")
    elif minutes > 1:
      print(f"  Active: {minutes} minutes ago")
    else:
      print(f"  Active: {dt.seconds} seconds ago")
  else:
    if dt.days < 365:
      print(f"  Active: {dt.days} days ago ({mtime.strftime('%b %-d')})")
    else:
      print(f"  Active: {dt.days} days ago ({mtime.strftime('%-m/%-d/%Y')})")
else:
  print("  Active: N/A")
print(" Sponsor:")

bashrc_default="""
# .bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi

# Uncomment the following line if you don't like systemctl's auto-paging feature:
# export SYSTEMD_PAGER=

# User specific aliases and functions
""".split('\n')

bash_profile_default = """
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/.local/bin:$HOME/bin

export PATH
""".split('\n')

def format_modules(module_lines):
  # convert lines with multiple modules to single lines
  # e.g., module load intel intel-mpi cudatoolkit
  singles = []
  for module_line in module_lines:
    items = module_line.split()
    if len(items) > 1 and items[0] == 'module' and (items[1] == 'load' or items[1] == 'add'):
      for module in module_line.split()[2:]:
        #if module.endswith('/64'): module = module[:module.index('/64')]
        singles.append("module load " + module)
    else:
      singles.append(module_line)
  return singles

def remove_comments_and_white_space(lines):
  remove_comments = [line for line in lines if not line.strip().startswith('#')]
  trans = str.maketrans('', '', ' \n\t\r')
  return ''.join(remove_comments).translate(trans)

def analyze_startup_script(flnm, default):
  global pythonpath
  global miniconda
  global anaconda
  global rlibs
  global rlibsuser
  aliases = 0
  exports = 0
  source = 0
  modules = []
  path = home + '/' + flnm
  if os.path.isfile(path):
    with open(path) as f:
      lines = f.readlines()
    startup_rm = remove_comments_and_white_space(lines)
    default_rm = remove_comments_and_white_space(default)
    if (startup_rm == default_rm):
      sp = "      " if (flnm == '.bashrc') else ""
      print(f"{gutter}{sp}~/{flnm}: default")
    else:
      for line in lines:
        if line.strip().startswith('#'): continue
        line = line.strip().lower() # lower causes problem with dirs with caps
        if (line.startswith('module') and ('load' in line or 'add' in line) and \
          not 'alias' in line):
          modules.append(line)
        # TODO remove comment checks
        if ('alias' in line and not line.startswith('#')):
          aliases += 1
        if ('export' in line and not line.startswith('#')):
          exports += 1
        #if ('source' in line and not line.startswith('#')):
        #  source += 1
        if ('pythonpath' in line and not line.startswith('#')):
          pythonpath=True
        if 'miniconda' in line.lower() and 'path' in line.lower():
          miniconda = True
        if 'anaconda' in line.lower() and 'path' in line.lower():
          anaconda = True
        if 'r_libs' in line.lower() and 'export' in line.lower() and '_user' not in line.lower():
          rlibs = True
        if 'r_libs_user' in line.lower() and 'export' in line.lower():
          rlibsuser = True
      #print(f"{flnm} >> alias:{aliases}  export:{exports}  source:{source}")
      if verbose:
        print(f"{gutter}~/{flnm}: alias:{aliases}  export:{exports}")
      else:
        print(f"{gutter}~/{flnm}: custom")
      if modules:
        mods = format_modules(modules)
        if verbose or len(mods) < 4:
          for mod in mods:
            print(f"{gutter}{term.bold}{term.red}{mod}{term.normal}")
        else:
          for mod in mods[:3]:
            print(f"{gutter}{term.bold}{term.red}{mod}{term.normal}")
          print(f"{gutter}{term.bold}{term.red}(plus {len(mods) - 3} more){term.normal}")
  else:
    print(f"{gutter}{flnm}: does not exist")

# .bashrc and .bash_profile
#divider(f"{term.bold}Environment{term.normal} (cat /home/{netid}/.bashrc)", '')
divider(f"{term.bold}Environment{term.normal}", '')
pythonpath = False
miniconda = False
anaconda = False
rlibs = False
rlibsuser = False
if not home_exists:
  print(f"{home} does not exist")
elif home_exists and not home_rx:
  print(f"{home} is private")
else:
  analyze_startup_script('.bashrc', bashrc_default)
  analyze_startup_script('.bash_profile', bash_profile_default)

# filesystems
def public_or_private(path):
  if is_rx(path):
    return f"{path}: public ({len(os.listdir(path))} items)"
  else:
    return f"{path}: private"

clusters = ['adroit', 'perseus', 'della', 'tiger', 'traverse']
is_cluster = any([cluster in host for cluster in clusters])

if is_cluster: # why do it this way? to distinguish from tigressdata?
  fs = StringBox()

  #path = '/home/' + netid
  #if os.path.isdir(path) and not is_rx(path):
  #  fs.append(f"{path}: private")

  path = '/scratch/gpfs/' + netid
  if os.path.isdir(path):
    fs.append(public_or_private(path))

  path = '/tigress/' + netid
  if Path(path).is_dir():
    fs.append(public_or_private(path))

  if ('della' in host or 'adroit' in host):
    path = '/scratch/network/' + netid
    if Path(path).is_dir():
      fs.append(public_or_private(path))

# align filesystems on colon
def align_on_colon(s):
  max_idx = max([line.index(':') for line in s])
  for i in range(fs.height):
    fs[i] = " " * (max_idx - fs[i].index(':')) + fs[i]
  return fs

if fs: fs = align_on_colon(fs)
if not home_exists or not home_rx: print("\n" * fs.height)
# print filesystems
with term.location():
  if len(fs):
    print(term.move_xy(width - fs.width - len(gutter), 12) + term.bold('Filesystems'))
    for i in range(fs.height):
      xc = width - fs.width - len(gutter)
      yc = 14 + i
      if 'home' in fs[i]:
        print(term.move_xy(xc, yc) + term.red + term.bold + fs[i] + term.normal)
      else:
        print(term.move_xy(xc, yc) + fs[i])

############
## groups ##
############
# TODO groups vary with cluster
cmd = "groups " + netid
output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
lines = output.stdout.decode("utf-8").split('\n')
# jdh4 : cses quijote (success)
# groups: aturing: no such user (fail)
grps = lines[0].split(':')[-1].split()
if len(grps) > 3:
  grps = ', '.join(grps[:3]) + ', ...'
else:
  grps = ', '.join(grps)
with term.location():
  print(term.move_xy(2, 6) + "Groups: " + grps)

######################
## home directories ##
######################
import csv
# TODO different path for adroit and tigressdata
# on adroit (and others?) consider: /home/jdh4/software/bin/lft
if host == "adroit":
  flnm = "/scratch/network/jdh4/python-utilities/.lft/combined_ls.csv"
elif host == "tigressdata":
  flnm = "/tiger/scratch/gpfs/jdh4/python-devel/lft/combined_ls.csv"
else:
  flnm = "/tigress/jdh4/python-devel/lft/combined_ls.csv"
with open(flnm, mode='r') as csv_file:
  csv_reader = csv.DictReader(csv_file)
  next(csv_reader)
  hdirs = []
  for row in csv_reader:
    if row["netid"] == netid:
      hdirs = [hdir for hdir in list(row.values())[1:] if hdir != '']
      break
if hdirs:
  with term.location(65, 4):
    print("/home")
    for hdir in sorted(hdirs):
      pre = "*" if hdir in host else " "
      print(term.move_x(67) + pre + hdir)

####################
## sponsor_report ##
####################

# TODO luet does not have account on tiger
# TODO hwaight does not have a sponsor since only adroit account

# $ sponsor_report jdh4
# No sponsored users for jdh4 (Jonathan D. Halverson)
# This user is sponsored by curt

# $ sponsor_report aturing
# FATAL ERROR: Could not find user aturing in Princeton LDAP

# $ sponsor_report hwaight
# hwaight (Hannah C. Waight) has no Tigress account

# $ sponsor_report ethier
# Manager ethier (Stephane Ethier) has sponsored the following users
#      gascione (George Ascione) has accounts on eddy

# Cluster eddy has these users gascione

cmd = "sponsor_report " + netid
try:
  output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
except subprocess.TimeoutExpired:
  #print("sponsor_report timed out looking for", netid)
  sponsor = None
except:
  # netid not in Princeton LDAP
  sponsor = None
else:
  lines = output.stdout.decode("utf-8").split('\n')
  if len(lines) > 1 and 'No sponsored users' in lines[0]:
    sponsor = lines[1].split()[-1]
  elif "Manager" in lines[0] and "has sponsored" in lines[0]:
    sponsor = netid
  else:
    sponsor = None

def remove_middle_initial(full_name):
  parts = full_name.split()
  cnt = len(parts)
  if (cnt > 2):
    for i in range(1, cnt - 1):
      if (parts[i].endswith('.') and (len(parts[i]) == 2)) or len(parts[i]) == 1:
        _ = parts.pop(i)
      return ' '.join(parts)
  else:
    return full_name

if sponsor:
  accounts = []
  cmd = "sponsor_report " + sponsor
  try:
    output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
  except:
    pass
  else:
    lines = output.stdout.decode("utf-8").split('\n')
    for line in lines:
      if "Manager" in line and "has sponsored" in line:
        # Manager curt (Curtis W. Hillegas) has sponsored the following users
        sponsor_full_name = line.split('(')[1].split(')')[0]
        sponsor_full_name = remove_middle_initial(sponsor_full_name)
        with term.location():
          print(term.move_xy(1, 10) + f"Sponsor: {sponsor_full_name} ({sponsor})")
      if 0 and netid in line and 'has accounts on' in line:
        # jdh4 (Jonathan D. Halverson) has accounts on della, perseus, tiger, traverse
        accounts = line.split('has accounts')[-1].replace(',', '').split()[1:]
        if 'mcmillan' in accounts: accounts.remove('mcmillan')
        if 'eddy' in accounts: accounts.remove('eddy')

if 0:
  # check for account adroit and tigressdata (use threading while sponsorreport runs)
  path = '/tigress/jdh4/python-devel/lft'
  with open(path + '/adroit_getent.txt', 'r') as f:
    adroit_users = f.readlines()
  for user in adroit_users:
    if user == netid + '\n':
     accounts.append("adroit")
  # check for account on tigressdata
  with open(path + '/tigressdata_getent.txt', 'r') as f:
    tg_users = f.readlines()
  for user in tg_users:
    if user == netid + '\n':
      accounts.append("tigressdata")
  # print accounts
  with term.location(50, 5):
    for account in sorted(accounts):
      pre = "*" if account in host else " "
      print(term.move_x(50) + pre + account)

#      ___                                 ___           ___           ___     
#     /  /\        ___         ___        /__/\         /  /\         /__/\    
#    /  /::\      /__/|       /  /\       \  \:\       /  /::\        \  \:\   
#   /  /:/\:\    |  |:|      /  /:/        \__\:\     /  /:/\:\        \  \:\  
#  /  /:/~/:/    |  |:|     /  /:/     ___ /  /::\   /  /:/  \:\   _____\__\:\ 
# /__/:/ /:/   __|__|:|    /  /::\    /__/\  /:/\:\ /__/:/ \__\:\ /__/::::::::\
# \  \:\/:/   /__/::::\   /__/:/\:\   \  \:\/:/__\/ \  \:\ /  /:/ \  \:\~~\~~\/
#  \  \::/       ~\~~\:\  \__\/  \:\   \  \::/       \  \:\  /:/   \  \:\  ~~~ 
#   \  \:\         \  \:\      \  \:\   \  \:\        \  \:\/:/     \  \:\     
#    \  \:\         \__\/       \__\/    \  \:\        \  \::/       \  \:\    
#     \__\/                               \__\/         \__\/         \__\/    

def clean_python_packages(pkgs):
  noshow = ['lib', 'bin', '__pycache__', 'six', 'pasta', 'pip', 'wheel', \
            'setuptools', 'pkgconfig', '_pytest']
  pkgs_cleaned = []
  for pkg in pkgs:
    parts = pkg.split('-')
    if len(parts) > 1 and parts[1][0].isalpha():
      pkg_cleaned = '-'.join([parts[0], parts[1]])
    else:
      pkg_cleaned = parts[0]
    pkgs_cleaned.append(pkg_cleaned)
  return sorted(list(set(pkgs_cleaned) - set(noshow)), key=lambda p: p.lower())

def check_python(ppd):
  global printed_python_divider
  if not ppd:
    divider(term.bold('Python'), '')
    printed_python_divider = True
  return None

versions = ['2.6', '2.7', '3.6', '3.7', '3.8']
#frmt = "(%-m/%-d/%Y)"
frmt = "(%b %Y)"

# conda TODO what if R within .conda
printed_python_divider = False
path = home + '/.conda'
if home_exists and home_rx and os.path.isdir(path):
  if is_rx(path):
    path = home + '/.conda/envs'
    if os.path.isdir(path):
      if is_rx(path):
        envs = os.listdir(path)
        if '.conda_envs_dir_test' in envs: envs.remove('.conda_envs_dir_test')
        for env in envs:
          success_per_env = False
          for version in versions:
            path = f"{home}/.conda/envs/{env}/lib/python{version}/site-packages"
            if os.path.isdir(path) and is_rx(path):
              success_per_env = True
              if verbose:
                check_python(printed_python_divider)
                mtime = datetime.fromtimestamp(os.stat(f"{home}/.conda/envs/{env}").st_mtime)
                mtime = mtime.strftime(frmt)
                print(f"     ~/.conda/envs/{term.bold}{env}{term.normal}/lib/python"
                      f"{version}/site-packages {mtime}")
                pkgs = os.listdir(path)
                pkgs = [pkg for pkg in pkgs if os.path.isdir(os.path.join(path, pkg))]
                pkgs = clean_python_packages(pkgs)
                print_packages(pkgs, "python")
                print('-' * width)
              else:
                check_python(printed_python_divider)
                print(f"{gutter}~/.conda/envs/{term.bold}{env}{term.normal}")
          if not success_per_env:
            check_python(printed_python_divider)
            print(f"{gutter}~/.conda/envs/{env}: exists")
      else:
        check_python(printed_python_divider)
        print(f"{gutter}~/.conda/envs: private")
  else:
    check_python(printed_python_divider)
    print(f"{gutter}~/.conda: private")

# .local (pip install --user <package>)
path = home + '/.local'
if home_exists and home_rx and os.path.isdir(path) and is_rx(path):
  for version in versions:
    path = f"{home}/.local/lib/python{version}/site-packages"
    if os.path.isdir(path):
      if is_rx(path):
        check_python(printed_python_divider)
        if verbose:
          print(f"     ~/.local/lib/{term.bold}python{version}{term.normal}/site-packages")
          pkgs = os.listdir(path)
          pkgs = [pkg for pkg in pkgs if os.path.isdir(path + '/' + pkg)]
          pkgs = clean_python_packages(pkgs)
          print_packages(pkgs, "python")
          print('-' * width)
        else:
          print(f"{gutter}~/.local/lib/{term.bold}python{version}{term.normal}/site-packages")
      else:
        check_python(printed_python_divider)
        print(f"{gutter}~/.local/lib/{term.bold}python{version}{term.normal}/site-packages (private)")
        print('-' * width)
else:
  if printed_python_divider:
    print(f"{gutter}~/.local does not exist")

# .condarc
path = home + '/.condarc'
if home_exists and home_rx and os.path.isfile(path):
  print(f"{gutter}{term.bold}{term.red}~/.condarc{term.normal}: yes")

# .cache
path = home + '/.cache'
dot_cache = True if home_exists and home_rx and Path(path).exists() else False

if pythonpath: print(f"{gutter}PYTHONPATH was set")
if dot_cache and printed_python_divider: print(f"{gutter}~/.cache: yes")
if anaconda: print("anaconda: yes")
if miniconda: print("miniconda: yes")

def clean_r_packages(pkgs):
  noshow = []
  return sorted(list(set(pkgs) - set(noshow)), key=lambda p: p.lower())

# R packages
printed_r_divider = False
path = home + '/R'
if home_exists and home_rx and os.path.isdir(path):
  for version in ['3.3', '3.4', '3.5', '3.6', '4.0']:
    path = home + f"/R/x86_64-redhat-linux-gnu-library/{version}"
    if os.path.isdir(path):
      if is_rx(path):
        if not printed_r_divider:
          divider(term.bold('R'), '')
          printed_r_divider = True
        pkgs = os.listdir(path)
        pkgs = clean_r_packages(pkgs)
        if verbose:
          print(f"     ~/R/x86_64-redhat-linux-gnu-library/{term.bold}{version}{term.normal}")
          print_packages(pkgs, "R", max_chars=13, columns=6)
          print('-' * width)
        else:
          print(f"{gutter}~/R/x86_64-redhat-linux-gnu-library/{term.bold}{version}{term.normal}")
      else:
        print(f"{path} is private")
 
# R misc
path = home + '/.R/Makevars'
if printed_r_divider and (os.path.isfile(path) or rlibs or rlibsuser):
  print("-" * width)
  if os.path.isfile(path):
    print(f"{term.bold}{term.red}{path} exists{term.normal}")
  if rlibs: print("R_LIBS was set")
  if rlibsuser: print("R_LIBS_USER was set")

###########
## julia ##
###########
path = home + '/.julia'
if home_exists and home_rx and os.path.isdir(path):
  path = home + '/.julia/packages'
  if os.path.isdir(path):
    if is_rx(path):
      pkgs = os.listdir(path)
      if pkgs:
        if verbose:
          divider(term.bold('Julia') + ' (~/.julia/packages)', '')
          noshow = []
          pkgs = sorted(list(set(pkgs) - set(noshow)), key=lambda p: p.lower())
          print_packages(pkgs, "julia")
        else:
          divider(term.bold('Julia'), '')
          print(f"{gutter}~/.julia/packages")
    else:
      divider(term.bold('Julia'), '')
      print(f"{gutter}~/.julia/packages is private")

# ~/.matlab
path = home + '/.matlab'
if home_exists and home_rx and Path(path).exists():
  if is_rx(path):
    divider(term.bold('MATLAB'), '')
    # versions used via slurm or interactively
    versions_used = os.listdir(path)
    print(' '.join(versions_used))

# ondemand
path = home + '/ondemand'
if home_exists and home_rx and Path(path).exists():
  if is_rx(path):
    divider('ondemand', '')
    if Path(path + '/data/sys/dashboard/batch_connect/sys/rstudio_server').exists():
      print("Ondemand RStudio")

#          _____                   _______                   _____                    _____          
#         /\    \                 /::\    \                 /\    \                  /\    \         
#        /::\    \               /::::\    \               /::\    \                /::\    \        
#        \:::\    \             /::::::\    \             /::::\    \              /::::\    \       
#         \:::\    \           /::::::::\    \           /::::::\    \            /::::::\    \      
#          \:::\    \         /:::/~~\:::\    \         /:::/\:::\    \          /:::/\:::\    \     
#           \:::\    \       /:::/    \:::\    \       /:::/__\:::\    \        /:::/__\:::\    \    
#           /::::\    \     /:::/    / \:::\    \     /::::\   \:::\    \       \:::\   \:::\    \   
#  _____   /::::::\    \   /:::/____/   \:::\____\   /::::::\   \:::\    \    ___\:::\   \:::\    \  
# /\    \ /:::/\:::\    \ |:::|    |     |:::|    | /:::/\:::\   \:::\ ___\  /\   \:::\   \:::\    \ 
#/::\    /:::/  \:::\____\|:::|____|     |:::|    |/:::/__\:::\   \:::|    |/::\   \:::\   \:::\____\
#\:::\  /:::/    \::/    / \:::\    \   /:::/    / \:::\   \:::\  /:::|____|\:::\   \:::\   \::/    /
# \:::\/:::/    / \/____/   \:::\    \ /:::/    /   \:::\   \:::\/:::/    /  \:::\   \:::\   \/____/ 
#  \::::::/    /             \:::\    /:::/    /     \:::\   \::::::/    /    \:::\   \:::\    \     
#   \::::/    /               \:::\__/:::/    /       \:::\   \::::/    /      \:::\   \:::\____\    
#    \::/    /                 \::::::::/    /         \:::\  /:::/    /        \:::\  /:::/    /    
#     \/____/                   \::::::/    /           \:::\/:::/    /          \:::\/:::/    /     
#                                \::::/    /             \::::::/    /            \::::::/    /      
#                                 \::/____/               \::::/    /              \::::/    /       
#                                  ~~                      \::/____/                \::/    /        
#                                                           ~~                       \/____/         

print("\n " + term.bold("Jobs"))
print("=" * width)

# squeue
if is_cluster:
  cmd = "squeue -u " + netid
  output = subprocess.run(cmd, capture_output=True, shell=True, timeout=3)
  lines = output.stdout.decode("utf-8").split('\n')
  running = 0
  pending = 0
  qosmax = 0
  reqnode = 0
  for line in lines:
    if (' R ' in line): running += 1
    if (' PD ' in line): pending += 1
    if (' QOSMax' in line): qosmax += 1
    if ('ReqNodeNotAvail' in line): reqnode += 1
  if (running or pending or qosmax or reqnode):
    print(f"{gutter}Running: {running}   Pending: {pending}   QOSMax+: {qosmax}   ReqNodeNotAvail: {reqnode}")

# sshare
cmd = f"sshare -l -u {netid}"
output = subprocess.run(cmd, capture_output=True, shell=True, timeout=3)
lines = output.stdout.decode("utf-8").split('\n')
for i, line in enumerate(lines):
  if ' ' + netid + ' ' in line and i != 0:
    fairshare = f"{float(line.split()[7]):.2f}"
    group = lines[i - 1].split()[0].upper()
    normShares = float(lines[i - 1].split()[2])
    normUsage  = float(lines[i - 1].split()[4])
    if normShares == 0:
      ratio = "100%"
    else:
      ratio = int(round(100 * normUsage / normShares, -1))
      ratio = f"{ratio}%"
    gshare = f"{round(100 * normShares)}%"
    print(f"{gutter}Fairshare: {fairshare}   30-day {group} usage: {ratio}   {group} share of cluster: {gshare}")
    # TODO red if extreme numbers
print('-' * width)

###########
## sacct ##
###########

# https://wiki.hpcc.msu.edu/display/ITH/Show+Job+Steps+by+sacct+and+srun+Commands
# <jobid>.0 is first srun/mpirun job step
# <jobid>.1 is second srun/mpirun job step
# https://stackoverflow.com/questions/52447602/slurm-sacct-shows-batch-and-extern-job-names
# Each job contains multiple job steps and each step is accounted for.
# %j.batch accounts for the resources needed for the batch script
# %j.extern accounts for all resource usage by the job outside of slurm (e.g., ssh)
# %j is the overall job

state = {
'BF'  :'BOOT_FAIL',
'CA'  :'CANCELLED',
'CD'  :'COMPLETED',
'DL'  :'DEADLINE',
'F'   :'FAILED',
'NF'  :'NODE_FAIL',
'OOM' :'OUT_OF_MEMORY',
'PD'  :'PENDING',
'PR'  :'PREEMPTED',
'R'   :'RUNNING',
'RQ'  :'REQUEUED',
'RS'  :'RESIZING',
'RV'  :'REVOKED',
'S'   :'SUSPENDED',
'TO'  :'TIMEOUT'
}
state = dict(zip(state.values(), state.keys()))
days = 2
# sacct wants this format YYYY-MM-DD[THH:MM[:SS]]
start = datetime.fromtimestamp(time() - days * 24 * 60 * 60).strftime('%Y-%m-%d-%H:%M')
if (host == "tiger"):
  frmt = 'jobid%20,start,state,ncpus,nnodes,partition,reqgres,jobname%20,reqtres%40'
  cols = ['JOBID', 'START', 'ST', 'CORES', 'NODES', 'PART', 'reqgres', 'NAME', 'reqtres']
else:
  frmt = 'jobid%20,start,end,state,ncpus,nnodes,partition,jobname%20,reqtres%40'
  cols = ['JOBID', 'START', 'ST', 'CORES', 'NODES', 'PART', 'NAME', 'reqtres']
cmd = f"sacct -S {start} -u {netid} -o {frmt} -n | egrep -v '[0-9].extern |[0-9].batch |[0-9]\.[0-9] '"
output = subprocess.run(cmd, stdout=sPIPE, shell=True, timeout=3, text=True)
lines = output.stdout.split('\n')
if lines[-1] == '': lines = lines[:-1]
if (len(lines) == 0):
  print(f"{gutter}No jobs in last 48 hours")
else:
  if (len(lines) > 2):
    print(cols)
    if len(lines) > 6: lines = lines[-6:]
    for line in lines:
      items = line.split()
      # 2020-09-13T11:42:34
      items[1] = datetime.strptime(items[1], "%Y-%m-%dT%H:%M:%S").strftime("%-m/%-d %H:%M")
      items[2] = state[items[2]] if items[2] in state else items[2]
      items[2] = '  ' + items[2]
      items[2] = items[2][-3:]
      items[3] = '  ' + items[3]
      items[3] = items[3][-3:]
      print(' '.join(items))

# size of /home
if disk:
  try:
    cmd = "du -sh /home/" + netid + " 2>/dev/null"
    output = subprocess.run(cmd, capture_output=True, shell=True, timeout=15)
    lines = output.stdout.decode("utf-8").split('\n')
    divider('size of /home on ' + host, '')
    print(lines[0].split('\t')[0])
  except subprocess.TimeoutExpired:
    divider('size of /home', '')
    print('du took too long')
  except:
    divider('size of /home', '')
    print("du failed so no info")

# .ssh
# .Xauthority
# .allinea
# if tiger in host or tigressdata: checkgpu -u 
# add university vacation days and RC workshops
# ps aux | grep netid -> what are they running on the head node
# lsof

##############
## downtime ##
##############
def second_tues_of_month(year, month):
  import calendar
  c = calendar.Calendar(firstweekday=calendar.SUNDAY)
  monthcal = c.monthdatescalendar(year, month)
  all_tues_of_month = [day for week in monthcal for day in week if \
                       day.weekday() == calendar.TUESDAY and \
                       day.month == month]
  second_tues = all_tues_of_month[1]
  return second_tues

def previous_and_next_downtime_dates():
  '''Display days from/to the previous/next downtime and dates'''
  today = datetime.today().date()
  year = today.year
  month = today.month

  second_tues = second_tues_of_month(year, month)
  dt = today - second_tues

  fmt = '%b %-d'
  divider(f"{term.bold}Events{term.normal}", "")
  if dt.days >= 0:
    # downtime in current month is lower bound so get downtime next month
    month += 1
    month, year = (1, year + 1) if month == 13 else (month, year)
    previous_tues = second_tues
    upcoming_tues = second_tues_of_month(year, month)
  else:
    # downtime in current month is upper bound so get downtime previous month
    month -= 1
    month, year = (12, year - 1) if month == 0 else (month, year)
    previous_tues = second_tues_of_month(year, month)
    upcoming_tues = second_tues

  dt_previous = today - previous_tues
  dt_upcoming = upcoming_tues - today
  previous_tues = previous_tues.strftime(fmt)
  upcoming_tues = upcoming_tues.strftime(fmt)

  # format previous downtime
  clr = f"{term.bold}{term.red}" if dt_previous.days <= 3 else ""
  if dt_previous.days == 0:
    prv = f"{previous_tues} ({clr}today{term.normal})"
  elif dt_previous.days == 1:
    prv = f"{previous_tues} ({clr}yesterday{term.normal})"
  else:
    prv = f"{previous_tues} ({clr}{dt_previous.days} days ago{term.normal})"

  # format upcoming downtime
  clr = f"{term.bold}{term.red}" if dt_upcoming.days <= 7 else ""
  if dt_upcoming.days == 0:
    nxt = f"({clr}today{term.normal}) {upcoming_tues}"
  elif dt_upcoming.days == 1:
    nxt = f"({clr}tomorrow{term.normal}) {upcoming_tues}"
  else:
    nxt = f"({clr}{dt_upcoming.days} days ahead{term.normal}) {upcoming_tues}"

  if (dt_previous.days <= 5 or dt_upcoming.days <= 9):
    print(f"{gutter}{prv} --- Downtime --> {nxt}")
  return None

_ = previous_and_next_downtime_dates()

##################
## reservations ##
##################
cmd = "scontrol show reservation"
output = subprocess.run(cmd, stdout=sPIPE, shell=True, timeout=3, text=True)
lines = output.stdout.split('\n')
for line in lines:
  # ReservationName=hpcr StartTime=2020-11-10T16:30:00 ...
  if 'ReservationName=' in line and 'StartTime=' in line:
    items = line.split()
    if 'ReservationName=' in items[0]:
      name = items[0].split("=")[1]
      if 'StartTime=' in items[1]:
        stime = items[1].split("=")[1]
        when = datetime.strptime(stime, "%Y-%m-%dT%H:%M:%S").date()
        today = datetime.today().date()
        dt = when - today
        if (dt.days <= 10):
          print(f"{gutter}Reservation \"{name}\" in {dt.days} days on {stime}")

############
## events ##
############
def print_events(flnm, days_away=7):

  if host == "adroit":
    flnm = "/scratch/network/jdh4/python-utilities/.lft/" + flnm
  elif host == "tigressdata":
    flnm = "/tiger/scratch/gpfs/jdh4/python-devel/lft/" + flnm
  else:
    flnm = "/tigress/jdh4/python-devel/lft/" + flnm

  if os.path.isfile(flnm):
    with open(flnm, mode='r') as csv_file:
      csv_reader = csv.DictReader(csv_file)
      for row in csv_reader:
        event = row["event"]
        when = datetime.strptime(row["date"], "%m/%d/%Y").date()
        today = datetime.today().date()
        dt = when - today
        if (dt.days <= days_away):
          print(f"{gutter}{event} in {dt.days} days on {when}")
  return None

print_events("holidays.csv", days_away=10)
print_events("rc_workshops.csv", days_away=2)

print("")
print("")
