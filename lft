#!/scratch/gpfs/jdh4/blessed-env/bin/python -u

# post issues to https://github.com/jdh4/lft
# or write to halverson@princeton.edu

import os
import sys
sys.path.append('/scratch/gpfs/jdh4/gpustat') # to find dossier
sys.path.append('/tiger/scratch/gpfs/jdh4/gpustat') # to find dossier from tigressdata
import math
import subprocess
from pathlib import Path
from datetime import datetime
from time import time
from socket import gethostname
from dossier import ldap_plus
from blessed import Terminal
import concurrent.futures

# terminal preferences
term = Terminal()
width = 80
gutter = ' '

class StringBox(list):
  def __init__(self):
    super().__init__()
    self.width = 0
    self.height = 0
  def append(self, x):
    super().append(x)
    self.width = len(x) if len(x) > self.width else self.width
    self.height += 1
  def __setitem__(self, key, x):
    super().__setitem__(key, x)
    self.width = len(x) if len(x) > self.width else self.width

def print_packages(items, language, max_chars=15, columns=5):
  if language.lower() == "python":
    parallel = ['mpi4py', 'mpich', 'intel-openmp', 'dask', 'joblib']
    gpu      = ['cudatoolkit', 'cudnn', 'cupy', 'numba']
    green    = ['fenics', 'geopandas', 'tensorflow', 'tensorflow-gpu', 'torch', 'pystan']
    red      = parallel + gpu
  elif language.lower() == "r":
    parallel = ['furrr', 'Rmpi', 'doMPI', 'caret']
    trouble = ['sf', 'rstan', 'Rcpp']
    green = []
    red = parallel + trouble
  elif language.lower() == "julia":
    green = []
    red = []
  else:
    green = []
    red = []
 
  clr = []
  items.sort(key=lambda pkg: pkg.lower())
  for item in items:
    if item in green:
      clr.append(f"{term.bold}{term.green}")
    elif item in red:
      clr.append(f"{term.bold}{term.red}")
    else:
      clr.append("")

  rows = math.ceil(len(items) / columns)
  for i in range(rows):
    s = gutter
    for j in range(columns):
      idx = j + columns * i
      if idx < len(items):
        item = items[idx].strip()
        if len(item) > max_chars - 1: item = item[:max_chars - 2] + '+ '
        s += clr[idx] + item + term.normal + ' ' * max(0, max_chars - len(items[idx]))
    print(s)
  return None

def is_rx(path):
  # true if permissions are rx or rwx for other
  return oct(os.stat(path).st_mode)[-1] in ['5', '7']

def divider(title, msg):
  print("")
  print(" " + title)
  print("=" * width)
  if (msg != ''): print(msg)

######################################
## evaluate command-line parameters ##
######################################
def print_help():
  print("")
  print("lft is looking for trouble. Example usage:")
  print("     $ lft aturing")
  print("")
  print("Options:")
  print("     -h  Show this help menu")
  print("     -v  Produce verbose output")
  print("     -d  Compute the size of /home using du -sh")
  print("")
  sys.exit(0)

if (len(sys.argv) > 4):
  print("")
  print("ERROR: Wrong number of command-line parameters.")
  print_help()
if ('-h' in sys.argv or '--help' in sys.argv):
  print_help()
verbose = True if ('-v' in sys.argv) else False
disk    = True if ('-d' in sys.argv) else False


def get_user_info(x):
  return ldap_plus([x])

username = sys.argv[1].strip()
with concurrent.futures.ThreadPoolExecutor() as executor:
  future = executor.submit(get_user_info, username)
  person = future.result()
# what happens if ldapsearch fails?
netid = person[1][9]
# need to check if netid is legit before going forward

# check for existence and permissions of home directory
home_rx = False
home = '/home/' + netid
if Path(home).exists():
  home_exists = True
  if is_rx(home):
    home_rx = True
  else:
    home_rx = False
    print(f"{home} is not accessible.")
else:
  home_exists = False
  print(f"{home} does not exist.")

host = gethostname().lower()
mach = {
'tigercpu.princeton.edu':'tiger',
'tigergpu.princeton.edu':'tiger',
'della5.princeton.edu':'della',
'perseus':'perseus',
'traverse.princeton.edu':'traverse',
'adroit4':'adroit',
'tigressdata2.princeton.edu':'tigressdata'}
if (host not in mach): print("WARNING: host not found.")
host = mach[host]


print(term.home + term.clear)
#print(f"Terminal size: {term.width}x{term.height}")
message = f"{gutter}looking for trouble on {host} for {username}"
now = datetime.today().strftime('%-I:%M %p (%b %-d)')
num_spaces = width - len(message) - len(now) - len(gutter)
print("=" * width)
print(f"{message}{' ' * num_spaces}{now}")
print("=" * width)

p = person[1]
if p[9]:
 if netid == username:
   print("   NetID:", term.bold(p[9]))
 else:
   print(f"   NetID: {term.bold(p[9])} ({term.red}{username} is alias{term.normal})")
if p[0]: print("    Name:", p[0])
print("  Groups:")
print("    Dept:", p[1]) if p[1] else print("    Dept: unknown")
print("Position:", p[3]) if p[3] else print("Position: unknown")

# modification time of /home/<NetID>
if Path(home).exists():
  mtime = datetime.fromtimestamp(os.stat(home).st_mtime)
  dt = datetime.today() - mtime
  if dt.days == 0:
    hours = dt.seconds // 3600
    minutes = dt.seconds // 60
    if hours > 1:
      print(f"  Active: {hours} hours ago")
    elif minutes > 1:
      print(f"  Active: {minutes} minutes ago")
    else:
      print(f"  Active: {dt.seconds} seconds ago")
  else:
    if dt.days < 365:
      print(f"  Active: {dt.days} days ago ({mtime.strftime('%b %-d')})")
    else:
      print(f"  Active: {dt.days} days ago ({mtime.strftime('%-m/%-d/%Y')})")
else:
  print("  Active: N/A")
print(" Sponsor:")

bashrc_default="""
# .bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi

# Uncomment the following line if you don't like systemctl's auto-paging feature:
# export SYSTEMD_PAGER=

# User specific aliases and functions
""".split('\n')

bash_profile_default = """
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/.local/bin:$HOME/bin

export PATH
""".split('\n')


def format_modules(module_lines):
  # convert lines with multiple modules to single lines
  # e.g., module load intel intel-mpi cudatoolkit
  singles = []
  for module_line in module_lines:
    items = module_line.split()
    if len(items) > 1 and items[0] == 'module' and (items[1] == 'load' or items[1] == 'add'):
      for module in module_line.split()[2:]:
        if module.endswith('/64'): module = module[:module.index('/64')]
        singles.append("module load " + module)
    else:
      singles.append(module_line)
  return singles

def remove_comments_and_white_space(lines):
  remove_comments = [line for line in lines if not line.strip().startswith('#')]
  trans = str.maketrans('', '', ' \n\t\r')
  return ''.join(remove_comments).translate(trans)

def analyze_startup_script(flnm, default):
  global pythonpath
  global miniconda
  global anaconda
  global rlibs
  global rlibsuser
  aliases = 0
  exports = 0
  source = 0
  modules = []
  path = home + '/' + flnm
  if os.path.isfile(path):
    with open(path) as f:
      lines = f.readlines()
    startup_rm = remove_comments_and_white_space(lines)
    default_rm = remove_comments_and_white_space(default)
    if (startup_rm == default_rm):
      print(f"{flnm}: default")
    else:
      for line in lines:
        if line.strip().startswith('#'): continue
        line = line.strip().lower() # lower causes problem with dirs with caps
        if (line.startswith('module') and ('load' in line or 'add' in line) and \
          not 'alias' in line):
          modules.append(line)
        # TODO remove comment checks
        if ('alias' in line and not line.startswith('#')):
          aliases += 1
        if ('export' in line and not line.startswith('#')):
          exports += 1
        #if ('source' in line and not line.startswith('#')):
        #  source += 1
        if ('pythonpath' in line and not line.startswith('#')):
          pythonpath=True
        if 'miniconda' in line.lower() and 'path' in line.lower():
          miniconda = True
        if 'anaconda' in line.lower() and 'path' in line.lower():
          anaconda = True
        if 'r_libs=' in line.lower() and 'export' in line.lower():
          rlibs = True
        if 'r_libs_user' in line.lower() and 'export' in line.lower():
          rlibsuser = True
      #print(f"{flnm} >> alias:{aliases}  export:{exports}  source:{source}")
      print(f"{flnm}: alias:{aliases}  export:{exports}")
      if modules:
        mods = format_modules(modules)
        if verbose or len(mods) < 4:
          for mod in mods:
            print(f"   {term.bold}{term.red}{mod}{term.normal}")
        else:
          for mod in mods[:3]:
            print(f"   {term.bold}{term.red}{mod}{term.normal}")
          print(f"   {term.bold}{term.red}(plus {len(mods) - 3} more){term.normal}")
  else:
    print(f"{flnm}: does not exist")

# .bashrc and .bash_profile
#divider(f"{term.bold}Environment{term.normal} (cat /home/{netid}/.bashrc)", '')
divider(f"{term.bold}Environment{term.normal}", '')
pythonpath = False
miniconda = False
anaconda = False
rlibs = False
rlibsuser = False
if not home_exists:
  print(f"{home} does not exist")
elif home_exists and not home_rx:
  print(f"{home} is private")
else:
  analyze_startup_script('.bashrc', bashrc_default)
  analyze_startup_script('.bash_profile', bash_profile_default)

# filesystems
def public_or_private(path):
  if is_rx(path):
    return f"{path}: public ({len(os.listdir(path))} items)"
  else:
    return f"{path}: private"

clusters = ['adroit', 'perseus', 'della', 'tiger', 'traverse']
is_cluster = any([cluster in host for cluster in clusters])

if is_cluster: # why do it this way? to distinguish from tigressdata?
  fs = StringBox()

  path = '/home/' + netid
  if os.path.isdir(path) and not is_rx(path):
    fs.append(f"{path}: private")

  path = '/scratch/gpfs/' + netid
  if os.path.isdir(path):
    fs.append(public_or_private(path))

  path = '/tigress/' + netid
  if Path(path).exists():
    fs.append(public_or_private(path))

  if ('della' in host or 'adroit' in host):
    path = '/scratch/network/' + netid
    if Path(path).exists():
      fs.append(public_or_private(path))

# align filesystems on colon
def align_on_colon(s):
  max_idx = max([line.index(':') for line in s])
  for i in range(fs.height):
    fs[i] = " " * (max_idx - fs[i].index(':')) + fs[i]
  return fs

if fs: fs = align_on_colon(fs)
if not home_exists or not home_rx: print("\n" * fs.height)
# print filesystems
with term.location():
  print(term.move_xy(width - fs.width - len(gutter), 12) + term.bold('Filesystems'))
  for i in range(fs.height):
    xc = width - fs.width - len(gutter)
    yc = 14 + i
    if 'home' in fs[i]:
      print(term.move_xy(xc, yc) + term.red + term.bold + fs[i] + term.normal)
    else:
      print(term.move_xy(xc, yc) + fs[i])

# groups
cmd = "groups " + netid
output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
lines = output.stdout.decode("utf-8").split('\n')
# jdh4 : cses quijote
grps = lines[0].split(':')[-1].split()
if len(grps) > 3:
  grps = ', '.join(grps[:3]) + ', ...'
else:
  grps = ', '.join(grps)
with term.location():
  print(term.move_xy(2, 6) + "Groups: " + grps)

# home
import csv
# TODO different path for adroit and tigressdata
flnm = "/tigress/jdh4/python-devel/lft/combined_ls.csv"
with open(flnm, mode='r') as csv_file:
  csv_reader = csv.DictReader(csv_file)
  next(csv_reader)
  hdirs = []
  for row in csv_reader:
    if row["netid"] == netid:
      hdirs = [hdir for hdir in list(row.values())[1:] if hdir != '']
      break
if hdirs:
  with term.location(65, 4):
    print("/home")
    for hdir in sorted(hdirs):
      pre = "*" if hdir in host else " "
      print(term.move_x(67) + pre + hdir)

# sponsor_report
# TODO luet does not have account on tiger
# TODO hwaight does not have a sponsor since only adroit account
cmd = "sponsor_report " + netid
output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
lines = output.stdout.decode("utf-8").split('\n')
if 'No sponsored users' in lines[0]:
  # This user is sponsored by curt
  sponsor = lines[1].split()[-1]
elif "Manager" in lines[0] and "has sponsored" in lines[0]:
  sponsor = netid
elif "has no Tigress account" in lines[0]:
  sponsor = ''
# how to get clusters for managers?

def remove_middle_initial(full_name):
  parts = full_name.split()
  cnt = len(parts)
  if (cnt > 2):
    for i in range(1, cnt - 1):
      if (parts[i].endswith('.') and (len(parts[i]) == 2)) or len(parts[i]) == 1:
        _ = parts.pop(i)
      return ' '.join(parts)
  else:
    return full_name

accounts = []
cmd = "sponsor_report " + sponsor
output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
lines = output.stdout.decode("utf-8").split('\n')
for line in lines:
  if "Manager" in line and "has sponsored" in line:
    # Manager curt (Curtis W. Hillegas) has sponsored the following users
    sponsor_full_name = line.split('(')[1].split(')')[0]
    sponsor_full_name = remove_middle_initial(sponsor_full_name)
    with term.location():
      print(term.move_xy(1, 10) + f"Sponsor: {sponsor_full_name} ({sponsor})")
  if netid in line and 'has accounts on' in line:
    # jdh4 (Jonathan D. Halverson) has accounts on della, perseus, tiger, traverse
    accounts = line.split('has accounts')[-1].replace(',', '').split()[1:]
    if 'mcmillan' in accounts: accounts.remove('mcmillan')
    if 'eddy' in accounts: accounts.remove('eddy')

# check for account adroit and tigressdata (use threading while sponsorreport runs)
path = '/tigress/jdh4/python-devel/lft'
with open(path + '/adroit_getent.txt', 'r') as f:
  adroit_users = f.readlines()
for user in adroit_users:
  if user == netid + '\n':
   accounts.append("adroit")
# check for account on tigressdata
with open(path + '/tigressdata_getent.txt', 'r') as f:
  tg_users = f.readlines()
for user in tg_users:
  if user == netid + '\n':
    accounts.append("tigressdata")
# print accounts
with term.location(50, 5):
  for account in sorted(accounts):
    pre = "*" if account in host else " "
    print(term.move_x(50) + pre + account)

def clean_python_packages(pkgs):
  noshow = ['lib', 'bin', '__pycache__', 'six', 'pasta', 'pip', 'wheel', \
            'setuptools', 'pkgconfig', '_pytest']
  pkgs_cleaned = []
  for pkg in pkgs:
    parts = pkg.split('-')
    if len(parts) > 1 and parts[1][0].isalpha():
      pkg_cleaned = '-'.join([parts[0], parts[1]])
    else:
      pkg_cleaned = parts[0]
    pkgs_cleaned.append(pkg_cleaned)
  return list(set(pkgs_cleaned) - set(noshow))

# .conda
versions = ['2.6', '2.7', '3.6', '3.7', '3.8']

# conda environments
# TODO is the package called fenics or something else
# TODO with verbose show certain libs: /home/jdh4/.conda/envs/tf2-gpu/lib

divider(term.bold('Python'), '')
dot_conda = home + '/.conda'
if home_exists and home_rx and os.path.isdir(dot_conda) and is_rx(dot_conda):
  path = dot_conda + '/envs'
  if os.path.isdir(path) and is_rx(path):
    envs = os.listdir(path)
    if '.conda_envs_dir_test' in envs: envs.remove('.conda_envs_dir_test')
    for env in envs:
      mtime = datetime.fromtimestamp(os.stat(dot_conda + f'/envs/{env}').st_mtime)
      if not verbose:
        print(gutter, '~/.conda/envs/' + term.bold(env), mtime.strftime(' (%-m/%-d/%Y)'))
      else:
        success = False
        for version in versions:
          path = f"{home}/.conda/envs/{env}/lib/python{version}/site-packages"
          if os.path.isdir(path) and is_rx(path):
            print(f"    {gutter}~/.conda/envs/{term.bold}{env}{term.normal}/lib/python"
                  f"{version}/site-packages {mtime.strftime(' (%-m/%-d/%y)')}")
            pkgs = os.listdir(path)
            pkgs = [pkg for pkg in pkgs if os.path.isdir(os.path.join(path, pkg))]
            pkgs = clean_python_packages(pkgs)
            print_packages(pkgs, "python")
            success = True
            print('-' * width)
        if not success: print(f"{home}/.conda/envs/{env}: packages are private")

# .local (pip install --user <package>)
path = home + '/.local'
if home_exists and home_rx and os.path.isdir(path) and is_rx(path):
  for version in versions:
    path = f"{home}/.local/lib/python{version}/site-packages"
    if os.path.isdir(path):
      if is_rx(path):
        if verbose:
          print(path)
          pkgs = os.listdir(path)
          pkgs = [pkg for pkg in pkgs if os.path.isdir(path + '/' + pkg)]
          pkgs = clean_python_packages(pkgs)
          print_packages(pkgs, "python")
          print('-' * width)
        else:
          print(path)
          print('-' * width)
      else:
        print(f"{path} is private")
        print('-' * width)
else:
  print(path, "does not exist")

# .condarc
path = home + '/.condarc'
if home_exists and home_rx and Path(path).exists():
  print(f"{term.bold}{term.red}~/.condarc{term.normal} was found")

# .cache
path = home + '/.cache'
dot_cache = True if home_exists and home_rx and Path(path).exists() else False

if pythonpath: print(f"PYTHONPATH was set")
if dot_cache: print("~/.cache: yes")
if anaconda: print("anaconda: yes")
if miniconda: print("miniconda: yes")

def clean_r_packages(pkgs):
  noshow = []
  pkgs_cleaned = []
  for pkg in pkgs:
    parts = pkg.split('-')
    if len(parts) > 1 and parts[1][0].isalpha():
      pkg_cleaned = '-'.join([parts[0], parts[1]])
    else:
      pkg_cleaned = parts[0]
    pkgs_cleaned.append(pkg_cleaned)
  return list(set(pkgs_cleaned) - set(noshow))

# R
first_time = True
path = home + '/R'
if home_exists and home_rx and os.path.isdir(path):
  for version in ['3.6', '4.0']:
    path = home + f"/R/x86_64-redhat-linux-gnu-library/{version}"
    if os.path.isdir(path):
      if is_rx(path):
        if first_time:
          divider(term.bold('R'), '')
          first_time = False
        pkgs = os.listdir(path)
        #pkgs = clean_r_packages(pkgs)
        print(f"     ~/R/x86_64-redhat-linux-gnu-library/{term.bold}{version}{term.normal}")
        if verbose: print_packages(pkgs, "R", max_chars=13, columns=6)
      else:
        print(f"{path} is private")
 
# Makevars
makevars = home + '/.R/Makevars'
if os.path.isfile(makevars):
  print(makevars, "exists")
if rlibs: print("R_LIBS was set")
if rlibsuser: print("R_LIBS_USER was set")

#print(os.path.isfile(home + '/.bbashrc')) # gives false for luet
#print(os.path.isfile(home + '/.bashrc'))  # gives false for luet
# need to figure out when to use Path, os.path. and is_rx
# need something like home_exists_and_rx

# ~/.julia
path = home + '/.julia/packages'
if home_exists and home_rx and Path(path).exists():
  if is_rx(path):
    pkgs = os.listdir(path)
    if pkgs: divider('julia', '')
    if verbose: print_packages(pkgs, "julia")

# ~/.matlab
path = home + '/.matlab'
if home_exists and home_rx and Path(path).exists():
  if is_rx(path):
    divider(term.bold('MATLAB'), '')
    # versions used via slurm or interactively
    versions_used = os.listdir(path)
    print(' '.join(versions_used))

# RLIBS or whatever people set in .bashrc

# ondemand
path = home + '/ondemand'
if home_exists and home_rx and Path(path).exists():
  if is_rx(path):
    divider('ondemand', '')
    if Path(path + '/data/sys/dashboard/batch_connect/sys/rstudio_server').exists():
      print("Ondemand RStudio")

print("\n " + term.bold("Jobs"))
print("=" * width)

# squeue
if is_cluster:
  cmd = "squeue -u " + netid
  output = subprocess.run(cmd, capture_output=True, shell=True, timeout=3)
  lines = output.stdout.decode("utf-8").split('\n')
  running = 0
  pending = 0
  qosmax = 0
  reqnode = 0
  for line in lines:
    if (' R ' in line): running += 1
    if (' PD ' in line): pending += 1
    if (' QOSMax' in line): qosmax += 1
    if ('ReqNodeNotAvail' in line): reqnode += 1
  if (running or pending or qosmax or reqnode):
    #print('-' * width)
    print(f"squeue -u {netid} >> Running: {running}  Pending: {pending}  QOSMax+: {qosmax}  ReqNodeNotAvail: {reqnode}")

# sshare
cmd = f"sshare -l -u {netid}"
output = subprocess.run(cmd, capture_output=True, shell=True, timeout=3)
lines = output.stdout.decode("utf-8").split('\n')
for i, line in enumerate(lines):
  if ' ' + netid + ' ' in line and i != 0:
    fairshare = f"{float(line.split()[7]):.2f}"
    group = lines[i - 1].split()[0]
    normShares = float(lines[i - 1].split()[2])
    normUsage  = float(lines[i - 1].split()[4])
    if normShares == 0:
      ratio = "100%"
    else:
      ratio = int(round(100 * normUsage / normShares, -1))
      ratio = f"{ratio}%"
    print(fairshare, ratio, group)
    print(f"Group ownership of cluster: {round(100 * normShares)}%")
    # red if extreme numbers

# sacct
start_stamp = datetime.fromtimestamp(time() - 24 * 60 * 60).strftime('%Y-%m-%d-%H:%M')
# sacct wants this format YYYY-MM-DD[THH:MM[:SS]]
cmd = f"sacct -S {start_stamp} -u {netid} | egrep -v 'extern|batch|\.0 ' 2>/dev/null"
output = subprocess.run(cmd, capture_output=True, shell=True, timeout=3)
lines = output.stdout.decode("utf-8").split('\n')
if (len(lines) > 3):
  print(f'sacct -u {netid} on {host}', '')
  print('-' * width)
  print(lines[0])
  if len(lines) > 6: lines = lines[-6:]
  print('\n'.join(lines))
  # TODO column labels can display twice and "No jobs in last 24 hours"

if verbose:
  pass
  # scontrol show reservation

# size of /home
if disk:
  try:
    cmd = "du -sh /home/" + netid + " 2>/dev/null"
    output = subprocess.run(cmd, capture_output=True, shell=True, timeout=15)
    lines = output.stdout.decode("utf-8").split('\n')
    divider('size of /home on ' + host, '')
    print(lines[0].split('\t')[0])
  except subprocess.TimeoutExpired:
    divider('size of /home', '')
    print('du took too long')
  except:
    divider('size of /home', '')
    print("du failed so no info")

# .ssh
# .Xauthority
# .allinea
# cd /home/netid
# cat /home/netid/.bashrc
# cat /home/netid/.bash_profile
# if tiger in host or tigressdata: checkgpu -u 
# add university vacation days and RC workshops

# ps aux | grep netid -> what are they running on the head node
# lsof

# downtime
def second_tues_of_month(year, month):
  import calendar
  c = calendar.Calendar(firstweekday=calendar.SUNDAY)
  monthcal = c.monthdatescalendar(year, month)
  all_tues_of_month = [day for week in monthcal for day in week if \
                       day.weekday() == calendar.TUESDAY and \
                       day.month == month]
  second_tues = all_tues_of_month[1]
  return second_tues

def previous_and_next_downtime_dates():
  '''Display days from/to the previous/next downtime and dates'''
  today = datetime.today().date()
  year = today.year
  month = today.month

  second_tues = second_tues_of_month(year, month)
  dt = today - second_tues

  fmt = '%b %-d'
  divider('downtime', '')
  if dt.days >= 0:
    # downtime in current month is lower bound so get downtime next month
    month += 1
    month, year = (1, year + 1) if month == 13 else (month, year)
    previous_tues = second_tues
    upcoming_tues = second_tues_of_month(year, month)
  else:
    # downtime in current month is upper bound so get downtime previous month
    month -= 1
    month, year = (12, year - 1) if month == 0 else (month, year)
    previous_tues = second_tues_of_month(year, month)
    upcoming_tues = second_tues

  dt_previous = today - previous_tues
  dt_upcoming = upcoming_tues - today
  previous_tues = previous_tues.strftime(fmt)
  upcoming_tues = upcoming_tues.strftime(fmt)

  clr = f"{term.bold}{term.red}" if dt_previous.days <= 3 else ""
  prv = f"{previous_tues} ({clr}{dt_previous.days} days ago{term.normal})"
  clr = f"{term.bold}{term.red}" if dt_upcoming.days <= 7 else ""
  nxt = f"({clr}{dt_upcoming.days} days ahead{term.normal}) {upcoming_tues}"
  print(f"{prv} --- Downtime --> {nxt}")
  return None

_ = previous_and_next_downtime_dates()

print("")
print("")
