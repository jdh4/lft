#!/usr/licensed/anaconda3/2020.2/bin/python
# ltf is looking for trouble

# $ find /home -maxdepth 2 -name .bashrc -type f -exec diff -q /home/csimao/.bashrc {} \; 2>/dev/null | wc -l
# 435
# $ find /home -maxdepth 2 -name .bashrc -type f 2>/dev/null | wc -l
# 930
# $ ls -ld /home/* | wc -l
# 957
# $ find /home -maxdepth 2 -name .bashrc -type f -exec diff -q /home/jdh4/.bashrc {} \; 2>/dev/null | wc -l
# 929

import os
import sys
sys.path = list(filter(lambda p: p.startswith("/usr"), sys.path))
sys.path.append('/scratch/gpfs/jdh4/gpustat') # to find dossier
sys.path.append('/tiger/scratch/gpfs/jdh4/gpustat') # to find dossier from tigressdata
import math
import subprocess
from socket import gethostname
from dossier import ldap_plus

def print_help():
  print("lft is looking for trouble. Example usage:")
  print("     $ lft aturing")

def print_columns(items, columns=5):
  items.sort()
  max_chars = 15
  rows = math.ceil(len(items) / columns)
  for i in range(rows):
    s = ""
    for j in range(columns):
      idx = j + columns * i
      if idx < len(items):
        s += items[idx].strip() + ' ' * (max_chars - len(items[idx])) + "\t"
    print(s)
  return None

def is_rx(path):
  # True if permissions are rx or rwx
  return oct(os.stat(path).st_mode)[-1] in ['5', '7']

def divider(title, msg):
  print("")
  #print("###############################################################################")
  print("# " + title)
  print("===============================================================================")
  if (msg != ''): print(msg)

if ('-h' in ''.join(sys.argv) or '--help' in ''.join(sys.argv)):
  print_help()

if (len(sys.argv) != 2):
  print("Wrong number of command-line parameters. Example usage: $ lft aturing")
  sys.exit(0)

netid = sys.argv[1].strip()

from pathlib import Path
home = '/home/' + netid
if Path(home).exists():
  if not is_rx(home):
    print(home, "is not accessible.")
    sys.exit(0)
else:
  print(home, "does not exist.")
  sys.exit(0)

host = gethostname().lower()

print(chr(27)+'[2j')
print('\033c')
print('\x1bc')
print("===============================================================================")
print("===============================================================================")
print("===============================================================================")
print("lft is looking for trouble on", host)
print("===============================================================================")

# ldapsearch
person = ldap_plus([netid])
p = person[1]
if p[0]: print("Name:", p[0])
if p[1]: print("Dept:", p[1])
if p[3]: print("Position:", p[3])
if p[7]: print("Sponsor:", p[7])
if p[9]: print("NetID:", p[9])

# modification time of /home/<NetID>
from datetime import datetime
from time import time
mtime = datetime.fromtimestamp(os.stat(home).st_mtime).strftime('%Y-%m-%d %H:%M:%S')
print("Last modified /home:", mtime)

brc_default="""
# .bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
	. /etc/bashrc
fi

# Uncomment the following line if you don't like systemctl's auto-paging feature:
# export SYSTEMD_PAGER=

# User specific aliases and functions
"""

bpro_default = """
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
	. ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/.local/bin:$HOME/bin

export PATH
"""

def format_modules(module_lines):
  # convert lines with multiple modules to single lines
  # e.g., module load intel intel-mpi cudatoolkit
  singles = []
  for module_line in module_lines:
    items = module_line.split()
    if len(items) > 1 and items[0] == 'module' and (items[1] == 'load' or items[1] == 'add'):
      for module in module_line.split()[2:]:
        singles.append("module load " + module) 
    else:
      singles.append(module_line)
  return singles

# .bashrc
divider('.bashrc', '')
aliases = 0
exports = 0
modules = []
if Path(home + '/.bashrc').exists():
  with open(home + '/.bashrc') as f:
    brc = f.read()
    if ('\n' + brc == brc_default):
      print("Default .bashrc")
    else:
      print("Custom .bashrc")
      lines = brc.split('\n')
      for line in lines:
        line = line.strip().lower()
        if (line.startswith('module') and ('load' in line or 'add' in line) and
            not 'alias' in line):
          modules.append(line)
        if ('alias' in line and not line.startswith('#')):
          aliases += 1
        if ('export' in line and not line.startswith('#')):
          exports += 1
        # check anaconda3 or miniconda3 in .bashrc
        if line.strip().startswith('#'): continue
        if 'miniconda' in line.lower() and 'path' in line.lower():
          print('miniconda')
        if 'anaconda' in line.lower() and 'path' in line.lower():
          print('anaconda')
      print("\t Number of aliases:", aliases)
      print("\t Number of exports:", exports)
      if modules:
        for module in format_modules(modules):
          print("\t", module)

# bash_profile
# TODO: examine this as like .bashrc for modules and aliases
path = home + '/.bash_profile'
if Path(path).exists():
  with open(path) as f:
    bpro = f.read()
    if ('\n' + bpro != bpro_default):
      divider('.bash_profile', '')
      print("Custom .bash_profile")

# .conda
divider('Python', '')
dot_conda = home + '/.conda'
if Path(dot_conda).exists():
  envs_path = dot_conda + '/envs'
  if Path(envs_path).exists():
    envs = os.listdir(envs_path)
    if '.conda_envs_dir_test' in envs: envs.remove('.conda_envs_dir_test')
    print("~/.conda envs:")
    for env in envs:
      print("\t", env)
  pkgs = dot_conda + '/pkgs'
  if Path(pkgs).exists():
    patterns = ['mpi4py', 'mpich', 'cudatoolkit', 'keras', 'tensorflow', 'numpy', \
                'scipy', 'matplotlib', 'pandas', 'pytorch', 'geopandas']
    found = set([p for p in patterns for pkg in os.listdir(pkgs) if p in pkg])
    #print("~/.conda pkgs:", ' '.join(found))
    print("~/.conda pkgs:")
    print_columns([pkg.split('-')[0] for pkg in os.listdir(pkgs)])

# .condarc
path = home + '/.condarc'
if Path(path).exists():
  divider('~/.condarc', '.condarc was found')

# .local
# pip install --user <package>
path = home + '/.local'
if os.path.isdir(path):
  if is_rx(path):
    versions = ['2.7', '3.6', '3.7', '3.8']
    for version in versions:
      path = home + '/.local/lib/python' + version + '/site-packages'
      if os.path.isdir(path) and is_rx(path):
        pkgs = os.listdir(path)
        print("== --user ==", path, "==")
        if pkgs: print_columns([pkg.split('-')[0] for pkg in pkgs])
  else:
    print(path, "is not accessible")
else:
  print(path, "does not exist")

# PYTHONPATH

# .cache
path = home + '/.cache'
if Path(path).exists():
  divider('~/.cache', '.cache was found')

# R
path = home + '/R'
if Path(path).exists():
  path = home + '/R/x86_64-redhat-linux-gnu-library/3.6' #TODO: 4.0
  divider('R', '')
  if Path(path).exists() and is_rx(path):
    pkgs = os.listdir(path)
    patterns = ['sf', 'dplyr', 'lubridate', 'tidyverse', 'tibble', 'ggplot2', 'caret', \
                'Rmpi', 'doMPI', 'data.table']
    found = set([p for p in patterns for pkg in pkgs if p in pkg])
    print("R pkgs:", ' '.join(found))
    print_columns(pkgs)
 
# Makevars
makevars = home + '/.R/Makevars'
if os.path.isfile(makevars):
  print(makevars, "exists")

# filesystems
divider('filesystems', '')
if ('adroit' in host):
  path = '/scratch/network/' + netid
  if is_rx(path) and Path(path).exists():
    print(path, "is public")

clusters = ['perseus', 'della', 'tiger', 'traverse']
is_cluster = any([cluster in host for cluster in clusters])

if is_cluster:
  path = '/scratch/gpfs/' + netid
  #if Path(path).exists():
  if os.path.isdir(path):
    print(path, "is public (" + str(len(os.listdir(path))), "items)") if is_rx(path) else print(path, "is private")
  path = '/tigress/' + netid
  if Path(path).exists():
    print('     ' + path, "is public (" + str(len(os.listdir(path))), "items)") if is_rx(path) else print(path, "is private")

# RLIBS or whatever people set in .bashrc

# ondemand

# squeue
if is_cluster:
  cmd = "squeue -u " + netid
  output = subprocess.run(cmd, capture_output=True, shell=True, timeout=3)
  lines = output.stdout.decode("utf-8").split('\n')
  running = 0
  queued = 0
  for line in lines:
    if (' R ' in line): running += 1
    if (' PD ' in line): queued += 1
  if (running or queued):
    msg =  "Number of running jobs: " + str(running) + "\n"
    msg += "Number of queued jobs: " + str(queued)
    divider('squeue', msg)

# todo: get accounts on adroit by cron and ssh/scp

# sponsor_report
divider('sponsor_report', '')
cmd = "sponsor_report " + netid
output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
lines = output.stdout.decode("utf-8").split('\n')
if 'No sponsored users' in lines[0]:
  # This user is sponsored by curt
  sponsor = lines[1].split()[-1]
elif "Manager" in lines[0] and "has sponsored" in lines[0]:
  sponsor = netid
# how to get clusters for managers?

cmd = "sponsor_report " + sponsor
output = subprocess.run(cmd, capture_output=True, shell=True, timeout=5)
lines = output.stdout.decode("utf-8").split('\n')
for line in lines:
  if "Manager" in line and "has sponsored" in line:
    # Manager curt (Curtis W. Hillegas) has sponsored the following users
    sponsor_full_name = line.split('(')[1].split(')')[0]
    print("Sponsor:", sponsor_full_name)
  if netid in line and 'has accounts on' in line:
    # jdh4 (Jonathan D. Halverson) has accounts on della, perseus, tiger, traverse
    clusters = line.split('has accounts')[-1].replace(',', '').split()[1:]
    if 'mcmillan' in clusters: clusters.remove('mcmillan')
    print("Clusters:", ' '.join(clusters))

# sacct
start_stamp = datetime.fromtimestamp(time() - 24 * 60 * 60).strftime('%Y-%m-%d-%H:%M')
# sacct wants this format YYYY-MM-DD[THH:MM[:SS]]
cmd = f"sacct -S {start_stamp} -u {netid} | egrep -v 'extern|batch|\.0 ' | tail -n 10 2>/dev/null"
output = subprocess.run(cmd, capture_output=True, shell=True, timeout=3)
lines = output.stdout.decode("utf-8").split('\n')
divider('sacct for last 24 hours' + host, '')
print('\n'.join(lines))

# size of /home
try:
  cmd = "du -sh /home/" + netid + " 2>/dev/null"
  output = subprocess.run(cmd, capture_output=True, shell=True, timeout=7)
  lines = output.stdout.decode("utf-8").split('\n')
  divider('size of /home on ' + host, '')
  print(lines[0].split('\t')[0])
except subprocess.TimeoutExpired:
  divider('size of /home', '')
  print('du took too long')
except:
  divider('size of /home', '')
  print("du failed so no info")

# downtime
divider('downtime', '')
import calendar
c = calendar.Calendar(firstweekday=calendar.SUNDAY)
today = datetime.today()
year = today.year; month = today.month

monthcal = c.monthdatescalendar(year, month)
all_tues_of_month = [day for week in monthcal for day in week if \
                     day.weekday() == calendar.TUESDAY and \
                     day.month == month]
second_tues = all_tues_of_month[1]
print(second_tues) # in x days or was 7 days ago

print("")
print("")
